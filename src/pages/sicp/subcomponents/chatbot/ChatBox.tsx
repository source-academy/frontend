import { Button } from '@blueprintjs/core';
import React, { useEffect, useRef, useState } from 'react';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { useTokens } from 'src/commons/utils/Hooks';
import { chat } from 'src/features/sicp/chatCompletion/api';
import { buildPrompt, SicpSection } from 'src/features/sicp/chatCompletion/chatCompletion';
import { SourceTheme } from 'src/features/sicp/SourceTheme';
import classes from 'src/styles/Chatbot.module.scss';

type Props = {
  getSection: () => SicpSection;
  getText: () => string;
};

type ChatMessage = { role: 'user' | 'bot'; content: string[] };
const initialMessage: ChatMessage = {
  content: ['Ask me something about this paragraph!'],
  role: 'bot'
};

const ChatBox: React.FC<Props> = ({ getSection, getText }) => {
  const chatRef = useRef<HTMLDivElement>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [messages, setMessages] = useState<ChatMessage[]>([initialMessage]);
  const [userInput, setUserInput] = useState('');
  const [contentHistory, setContentHistory] = useState<Array<string>>([]);
  const [roleHistory, setRoleHistory] = useState<Array<string>>([]);
  const tokens = useTokens();

  const handleUserInput = (event: React.ChangeEvent<HTMLInputElement>) => {
    setUserInput(event.target.value);
  };

  // To get code snippets
  const codeBlocks = (temp: string) => {
    return temp.split('```');
  };

  const sendMessage = async () => {
    if (userInput.trim() === '') {
      return;
    }
    // clean the input immediately after the user sends the message so that the user would not feel the lag
    const _userInput = userInput;
    const _messages = messages;
    setUserInput('');
    const blocks = codeBlocks(_userInput);
    setMessages([...messages, { role: 'user', content: blocks }]);
    setIsLoading(true);

    const prompt = buildPrompt(getSection(), getText());
    const payload: { role: string; content: string }[] = [{ role: 'system', content: prompt }];
    for (let i = 0; i < contentHistory.length; i++) {
      payload.push({ role: roleHistory[i], content: contentHistory[i] });
    }
    payload.push({ role: 'user', content: _userInput });
    chat(tokens, payload)
      .then(text => {
        const keptContentHistory =
          contentHistory.length >= 20 ? contentHistory.slice(2) : contentHistory;
        const keptRoleHistory = roleHistory.length >= 20 ? roleHistory.slice(2) : roleHistory;
        setContentHistory([...keptContentHistory, _userInput, text]);
        setRoleHistory([...keptRoleHistory, 'user', 'assistant']);
        setMessages([
          ..._messages,
          { role: 'user', content: blocks },
          {
            role: 'bot',
            content: [text + '\n\nThe answer is generated by GPT-4 and may not be correct.']
          }
        ]);
      })
      .catch(e => {
        setMessages([
          ..._messages,
          { role: 'user', content: blocks },
          { content: [`Sorry, I am down with a cold, please try again later.`], role: 'bot' }
        ]);
      })
      .finally(() => {
        setIsLoading(false);
      });
  };

  const cleanMessage = () => {
    setMessages([{ content: ['Ask me something about this paragraph!'], role: 'bot' }]);
    setContentHistory([]);
    setRoleHistory([]);
  };

  const renderMessageContent = (message: string | string[]) => {
    if (!Array.isArray(message)) {
      return message;
    }

    return message.map((block, index) =>
      // Assume that only javascript code snippets will appear
      block.substring(0, 10) === 'javascript' ? (
        <SyntaxHighlighter language="javascript" style={SourceTheme} key={index}>
          {block.substring(11, block.length)}
        </SyntaxHighlighter>
      ) : (
        block
      )
    );
  };

  const keyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {
    if (event.key === 'Enter') {
      sendMessage();
    }
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, isLoading]);

  const scrollToBottom = () => {
    chatRef.current?.scrollTo({ top: chatRef.current?.scrollHeight });
  };

  return (
    <div className={classes['chat-container']}>
      <div className={classes['chat-message']} ref={chatRef}>
        {messages.map((message, index) => (
          <div
            key={index}
            className={classes[`${message.role}`]}
            style={{ whiteSpace: 'pre-line' }}
          >
            {renderMessageContent(message.content)}
          </div>
        ))}
        {isLoading && <p>loading...</p>}
      </div>
      <input
        type="text"
        className={classes['user-input']}
        placeholder="Type your message here..."
        value={userInput}
        onChange={handleUserInput}
        onKeyDown={keyDown}
      />
      <div className={classes['button-container']}>
        <Button className={classes['button-send']} onClick={sendMessage}>
          Send
        </Button>
        <Button className={classes['button-clean']} onClick={cleanMessage}>
          Clean
        </Button>
      </div>
    </div>
  );
};

export default ChatBox;
